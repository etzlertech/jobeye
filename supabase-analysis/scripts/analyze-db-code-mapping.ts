#!/usr/bin/env npx tsx
/**
 * Database to Codebase Mapping Analysis Tool
 * 
 * This tool analyzes how each database table is used in the codebase by:
 * 1. Loading the latest database analysis (generated by analyze-supabase-live.ts)
 * 2. Scanning the codebase for table references using TypeScript AST parsing
 * 3. Building comprehensive mappings showing access patterns and relationships
 * 4. Generating YAML and Markdown reports for AI agents and humans
 * 
 * Usage: npm run analyze:db-mapping
 */

import { createClient } from '@supabase/supabase-js';
import * as fs from 'fs/promises';
import * as path from 'path';
import * as yaml from 'js-yaml';
import { MappingAnalyzer } from './mapping-analyzer';
import { MappingReportGenerator } from './mapping-report-generator';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config({ path: '.env.local' });

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;

if (!supabaseUrl || !supabaseKey) {
  console.error('‚ùå Missing required environment variables:');
  if (!supabaseUrl) console.error('   - NEXT_PUBLIC_SUPABASE_URL');
  if (!supabaseKey) console.error('   - SUPABASE_SERVICE_ROLE_KEY');
  process.exit(1);
}

async function loadLatestDatabaseAnalysis(): Promise<any> {
  const latestDir = path.join(process.cwd(), 'supabase-analysis/reports/latest');
  const yamlPath = path.join(latestDir, 'database-analysis.yaml');

  try {
    const yamlContent = await fs.readFile(yamlPath, 'utf8');
    return yaml.load(yamlContent);
  } catch (error) {
    console.error(`‚ùå Failed to load database analysis from ${yamlPath}`);
    console.error('   Please run "npm run analyze:supabase" first');
    throw error;
  }
}

async function archivePreviousReports(): Promise<void> {
  const baseDir = path.join(process.cwd(), 'supabase-analysis/mapping-reports');
  const latestDir = path.join(baseDir, 'latest');
  const archiveDir = path.join(baseDir, 'archive');

  try {
    // Check if latest directory exists
    await fs.access(latestDir);
    
    // Create archive directory if it doesn't exist
    await fs.mkdir(archiveDir, { recursive: true });
    
    // Move latest to archive with timestamp
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
    const archivePath = path.join(archiveDir, timestamp);
    
    await fs.rename(latestDir, archivePath);
    console.log(`üìÅ Archived previous reports to: ${archivePath}`);
  } catch (error) {
    // Latest directory doesn't exist, nothing to archive
  }
}

async function main() {
  console.log('üöÄ Database to Codebase Mapping Analysis');
  console.log('========================================\n');

  try {
    // Step 1: Load the latest database analysis
    console.log('üìä Loading database analysis...');
    const databaseAnalysis = await loadLatestDatabaseAnalysis();
    console.log(`‚úÖ Loaded analysis with ${databaseAnalysis.tables.length} tables\n`);

    // Step 2: Extract known table names
    const knownTables = databaseAnalysis.tables.map((t: any) => t.name);
    
    // Step 3: Archive previous mapping reports
    await archivePreviousReports();

    // Step 4: Create mapping analyzer
    const projectRoot = process.cwd();
    const analyzer = new MappingAnalyzer(knownTables, projectRoot);

    // Step 5: Run the mapping analysis
    const mappingAnalysis = await analyzer.analyze(databaseAnalysis);

    // Step 6: Generate reports
    const outputDir = path.join(projectRoot, 'supabase-analysis/mapping-reports/latest');
    const reportGenerator = new MappingReportGenerator();
    await reportGenerator.generateReports(mappingAnalysis, outputDir);

    // Step 7: Summary
    console.log('\nüìà Analysis Summary:');
    console.log(`   Total Tables: ${mappingAnalysis.totalTables}`);
    console.log(`   Tables with Code References: ${mappingAnalysis.mappedTables} (${Math.round(mappingAnalysis.mappedTables / mappingAnalysis.totalTables * 100)}%)`);
    console.log(`   Unused Tables: ${mappingAnalysis.unmappedTables} (${Math.round(mappingAnalysis.unmappedTables / mappingAnalysis.totalTables * 100)}%)`);
    console.log(`   Code Quality Issues: ${mappingAnalysis.codeQualityIssues.length}`);
    
    // Show top issues
    const highSeverityIssues = mappingAnalysis.codeQualityIssues.filter(i => i.severity === 'high');
    if (highSeverityIssues.length > 0) {
      console.log(`\n‚ö†Ô∏è  High Priority Issues (${highSeverityIssues.length}):`);
      highSeverityIssues.slice(0, 5).forEach(issue => {
        console.log(`   - ${issue.description}`);
      });
      if (highSeverityIssues.length > 5) {
        console.log(`   ... and ${highSeverityIssues.length - 5} more`);
      }
    }

    // Show top recommendations
    if (mappingAnalysis.recommendations.length > 0) {
      console.log('\nüí° Top Recommendations:');
      mappingAnalysis.recommendations.slice(0, 3).forEach((rec, idx) => {
        console.log(`   ${idx + 1}. ${rec}`);
      });
    }

    console.log('\n‚úÖ Analysis complete!');
    console.log(`üìÅ Reports saved to: ${outputDir}`);
    console.log('   - mapping-report.md (Human-readable report)');
    console.log('   - db-code-mapping.yaml (AI-agent friendly)');
    console.log('   - unused-tables.yaml (Cleanup candidates)');

  } catch (error) {
    console.error('\n‚ùå Analysis failed:', error);
    process.exit(1);
  }
}

// Run the analysis
main().catch(console.error);